하루 10분 c++


========================================
1-1. 변수 선언과 규칙
========================================
int a; // 선언('자료형' '변수명'; 꼴)
a = 7; // 대입
int b = 3; // 초기화(선언과 동시에 대입)

// 이중블록
{ int b;
	{
	int a;
	b = 3; //사용가능
	}
	a = 5; //사용불가
}
========================================
1-2. 정수형 자료형과 실수형 자료형
========================================
#include <climits>

정수형 
short(2byte)<int(4byte)<long(4byte)<long long(8byte)

unsigned int a; // unsigned는 음수값을 사용하지 못함
unsigned short b; // 0~65535(-31768~327677) 

실수형 
float a =3.14;
========================================
1-3. 문자형 자료형과 bool형 자료형
========================================
char
작은 문자형 + 작은따옴표 // 큰따옴표에는 null값이 포함

bool
0(false) or 1(true)

bool a = 0; // 0
bool b = 1; // 1
bool c = 10; // 1
========================================
1-4. const(상수) 제한자와 데이터형 변환
========================================
상수(const) 선언
#define PIE 3.141592 // c   
-> const float PIE 3.141592; //c++

PIE =10 // 한번 선언한 상수는 이후 변경 불가

데이터형 변환
typeName(a) = (typeName)a

EX) 문자형 -> 정수형으로 변환
char ch = 'M';
cout << (int)ch << "  " << int(ch) << endl; // 77 77
cout << static_cast<int>(ch) << endl; // 77
========================================
1-5. C++ 산술연산자(사칙연산 등)와 auto
========================================
>>(몫)
%(나머지)

데이터형 auto
auto x = 0.0; // float 
float y =0;
auto z = 0; // int
========================================
2-1. 배열(array)과 문자열
========================================
/*
배열 : 같은 데이터형의 집합
       : 배열을 다른 배열에 통째로 넣을 수 없음(string은 가능)
기본형태
typeName arrayName[arraySize]; ('자료형' '배열명'[배열사이즈]; 꼴)
-> short month[12]; // 선언 (12개의 short형 데이터 저장가능)
*/

short month[12] = { 1, 2, 3 }; // 콤마와 중괄호
cout << month[0] << endl;

// 문자열을 사용하려고 배열 이용
char a[5] = {'H', 'e', 'l', 'l', 'o'}; // 실행하면 Hello?@$^! 처럼 뒤에 이상한 문자가 붙음
char a[6] = {'H', 'e', 'l', 'l', 'o', '\0'}; # Hello 
-> char a[] = "Hello" // 큰따옴표에는 null값이 포함 -> 더효율적인 문자열 배열 가능
cout << a << endl;
========================================
2-2. 사용자 입력(cin, get/getline)과 string
========================================
#include <cstring> // strlen
strlen(name1) // 문자열 길이 반환
sizeof(name1) // 변수의 바이트 크기 반환

cin.getline(name1, Size) //whitespace 적용가능(띄어쓰기 이후 타이핑한 것도 출력)
= cin.get(name1, Size) 

배열 vs string(복합데이터형)
배열을 다른 배열에 통째로 넣을 수 없음
ex)
// 배열
char char1[20];
char char2[20] = 'jaguar';
char1 = char2; // 틀림(통째로 값을 대입할 수 없다.)
// string
string str1;
string str2 = "panda";
str1 = str2; // 통째로 값을 대입할 수 있다.
========================================
2-3. 구조체(struct)
========================================
구조체 : 다른 데이터형이 허용되는 데이터의 집합(클래스의 일종)
배열 :  같은 데이터형의 집합
구조체 vs 클래스
클래스는 클래스 내에 선언된 함수로만 초기화 가능
구조체는 함수의 외부에서도 빼고 초기화 가능하다.
구조체 외부에 함수와 달리 구조체 내에 함수는 inline으로 처리된다.

struct MyStruct
{
	string name; // 멤버
	string position;
	int heght;
	int weight;
} B ; //구조체를 정의하는 부분에서 중괄호 뒤에 변수명을 입력하면
새로운 구조체를 선언(// 초기화를 선언 + 구조체에 대입)하지 않아도
구조체가 자동으로 만들어짐

// MyStruct형 변수A
MyStruct A; //.(dot) = 구조체의 멤버연산자
A.name = "Son"
A.position = "Striker",
A.height = 183;
A.weight = 77;

// 초기화를 선언 + 구조체에 대입
MyStruct A = {
 	"Son"
	"Striker",
	183, 
	77
};

cout << A.name <<endl;
cout << A.position<<endl;
cout << A.height <<endl;
cout << A.weight <<endl;


구조체 역시 배열(대괄호로 크기 지정)로 선언 가능
배열 초기화(중괄호 사용)
MyStruct A[2] = { 
	{"A", "A", 1, 1 },
	{"B", "B", 2, 2 }};

cout << A[0].height <<endl;
========================================
2-4. 공용체와 열거체
========================================
둘다 복합데이터의 일종
union (공용체) : 서로 다른 데이터형을 한번에 한가지만 보관가능

union MyUnion
{
	int intVal;
	long longVal;
	float floatVal;
};

MyUnion test;
test.intVal = 3;

enum(열거체) : 기호 상수를 만드는 것에 대한 또다른 방법
enum spectrum {red, orange, green};
enum spectrum {red=0, orange=1, green=2}; // 명시적으로도 작성 가능
0에서부터 2까지 정수값을 각각 나타내는 기호 상수로 만듦

spectrum a = orange;
열거자 간에 산술연산은 허용x

int b;
b = orange //1
b = orange+3 //4
========================================
2-5. 포인터와 메모리 해제 1
========================================
주소값
#include <iostream>

using namespace std;

int main(){
	// 변수 선언 과정
	int val = 3;
	cout << &val << endl; // 0113FB20이 출력됨 
	return 0;
}

/* C++ : 객체지향 프로그래밍
컴파일 시간이 아닌 실행시간에 어떠한 결정을 내릴수있다.
c라는 재래적 프로그래밍 언어와 다르게 프로그래밍이 코드를 읽는 시간인 
컴파일 시간에 모든 것이 결정되는 것이 아니라 코드가 실행돼서 돌아가고 있는 시간에
결정을 내릴 수 있다.

재래적 절차적 프로그래밍 : 배열의 크기가 컴파일 시간에 미리 결정되어야 한다.
객체 지향 프로그래밍 : 배열의 크기를 실행 시간에 결정 가능
= 변수로 배열의 크기를 결정할 수 있다.
 
배열의 사이즈를 20으로 정했는데 하다보니 200정도가 필요하다.
c에서는 새로운 코드를 추가해야한다.
그래서 배열의 사이즈를 아예 200으로 맞춰놓자면 만약 사이즈가 20만 필요하면 엄청난 낭비가 발생
-> c++에서는 변수하나가 [20]으로 유지되다가 간헐적으로 [200]을 사용가능
-> 포인터
*/

포인터 : 사용할 주소에 이름을 붙인다
즉, 포인터는 포인터의 이름이 주소를 나타낸다.
간접값 연산자, 간접 참조 연산자

#include <iostream>

using namespace std;

int main(){

    int a = 6; // 수
    int* b; // 위치

    b = &a; // b로 초기화

    cout << "a의 값 " << a << endl; // 6
    cout << "*b의 값 " << *b << endl; // 6, 포인터로 선언된 변수b의 값을 확인할땐 *(간접참조연산자)를 붙임 

    cout << "a의 주소 " << &a << endl; //0033FAC0
    cout << "*b의 주소 " << b << endl ;//0033FAC0

    *b = *b + 1; // 포인터 값에 1을 더함

    cout << "이제 a의 값은 " << a << endl; // 7
     
    return 0
}


int *a; // c 스타일
-> int* a; // c++ 스타일
int* c,d // c는 포인터 변수, d는 int형 변수

증가연산자, 감소연산자

========================================
2-6. 포인터와 메모리 해제 2
========================================
new 연산자
어떤 데이터형을 원하는지 new연산자에게 알려주면, new 연산자는
그에 알맞은 크기의 메모리 블록을 찾아내고 그 블록의 주소를 리턴

int* pointer = new int;

delete 연산자
환수된 메모리는 프로그램의 다른부분이 다시 사용할 수 있다.
int* ps = new int;
delete ps; // new + delete
1. new로 대입하지 않은 메모리는 delete로 해제할 수 없다.
2. 같은 메모리 블록을 연달아 두번 연속 delete로 불가
3. new[](배열부여)로 메모리를 대입할 경우 delete로 해제한다.
4. 대괄호를 사용하지 않았다면 delete도 대괄호를 사용불가

#include <iostream>

using namespace std;

int main(){

    double* p3 = new double[3]; // double형 데이터 3개를 저장할 수 있는 공간을 대입한다.
    p3[0] = 0.2; // p3를 배열 이름처럼 취급한다.
    p3[1] = 0.5;
    p3[2] = 0.8;

    cout << "p3[1] is " << p3[1] << ".\n";

    p3 = p3 + 1; // 포인터를 증가시킨다. // 포인터 공간을 증가시킴 p3[0] = 0.5, p3[1]=0.8

    cout << "Now p3[0] is " << p3[0] << " and ";
    cout << "p3[1] is " << p3[1] << "\n.";

    p3 = p3-1;
    delete[] p3;

    return 0;
}
 
========================================
2-7. 포인터 연산
========================================
#include <iostream>
#define SIZE 20

using namespace std;

int main(){

    char animal[SIZE]; // 컴파일 시간에 배열의 크기를 정함
    char* ps;

    cout << "동물 이름을 입력하십시오.\n";
    cin >> animal;

    ps = new char[strlen(animal) +1]; // 동적 구조체=실행 시간에 배열의 크기를 정함 -> 메모리 차원에서 훨씬 유리
    // 동적 구조체 생성
    // temp* ps = new temp; // 멤버를 .이 아닌 ->로 표현해야함
    
    strcpy(ps, animal); // animal의 값을 ps에 복사하는 역할

    cout << "입력하신 동물 이름을 복사하였습니다." << endl;
    cout << "입력하신 동물 이름은 " << animal << "이고, 그 주소는 " << (int*)animal << " 입니다." << endl;
    cout << "복사된 동물 이름은 " << ps << "이고, 그 주소는 " << (int*)ps << " 입니다." << endl;
     
    delete[] ps;
    return 0;
}


 struct MyStruct
{
    char name[20];
    int age;
};

int main(){

    MyStruct* temp = new MyStruct;

    cout << "당신의 이름을 입력하십시오.\n";
    cin >> temp->name;

    cout << "당신의 나이를 입력하십시오.\n";
    cin >> (*temp).age;

    cout << "안녕하세요! " << temp->name << "씨!\n";
    cout << "당신은 " << temp->age << "살 이군요!\n";
    
    delete temp;
    return 0;
}
========================================
3-4. 반복문의 활용
========================================

int a[5] = { 1, 3, 5, 7, 9 }

for (int i = 0; i <5; i++){ // 초기화, 조건검사, 반복문 몸체 수행 순
    cout << i << endl;
}


// 중첩루프 : 2차원 배열
int temp[4][5];

========================================
3-5. 반복문 : 증가/감소 연산자와 관계표현식
========================================



========================================
3-6. while 루프와 do while 루프
========================================


========================================
3-7. 반복문의 활용
========================================





========================================
4-1. if 구문과 if else 구문
========================================
if (true)
	cout << "조건이 참입니다.",
if (false)
	cout << "조건이 거짓입니다.";



if (true){
	cout 
	cout <<endl;

else {
}

if (false)
else if (true)
else 




========================================
4-2. 논리 표현식
========================================

논리합(|| = or), 논리곱(&& = and), 논리부정 연산자(! = not )


========================================
4-3. switch 구문과 break continue 구문
========================================

switch (a)
{
case 1:
	cout << " 
	break;

case 2:
	cout << " 
	break;

defalut:
	cout
	break;
}



========================================
5-1. 함수의 기초
========================================



리턴값이 있는 타입
리턴값이 없는 타입





파라미터 : 함수의 특성을 나타내는 매개변수 
void helloCPP(int, int); //파라미터
int main() {
	helloCPP(times, times2) //전달인자, 아규먼트
	return 0;
}

void helloCPP(int n, int m) { //
}


========================================
5-2. 매개변수와 전달인자
========================================

========================================
5-3. 함수와 배열
========================================





========================================
5-4. 함수와 구조체
========================================

struct Time //구조체
{
	int hours; // 멤버
	int mins; // 멤버
};

 
Time sum(Time* t1, Time* t2) { // 매개변수가 구조체가 아닌 포인터변수 
	Time total;

	// 구조체.멤버 불가 간접멤버연산자(->)
	// 값에서 멤버로 접근할때 : .
	// 주소에서 멤버로 접근할때 : 간접멤버연산자(->) 
	total.mins = (t1->mins + t2->mins) % minsPerHr;
	total.hours = t1->hours + t2->hours +
			(t1->mins + t2->mins) / minsPerHr;

	return total;



========================================
5-5. 재귀함수와 함수를 지시하는 포인터
========================================

재귀
int main() {
void recurs(agumentList){
	if (condumentList

)



함수의 주소 얻는법
int main(){
	cout << func << endl;
	return 0;
}

int func(int n){
	return n+1;
}




========================================
6-1. 인라인 함수와 디폴트 매개변수
========================================
인라인 함수 : 프로그램의 실행속도를 높이기 위해 필요
inline float square(float x) {return x*x}

디폴트 매개변수: 매개변수가 없을때 대신 사용
 
int sumArr(int*, int n=1);
 
========================================
6-2. 참조 변수
========================================


========================================
6-3. 함수 오버로딩
========================================



========================================
6-4. 함수 템플릿
========================================

// class 혹은 typeName
template <class Any>




========================================
7-1. 분할 컴파일
========================================
555555555555555555555555555555555555555555555555555555555555
집계 데이터 유형 중 하나가 구조체
일반적으로 구조체 이름은 대문자로 시작하여 변수 이름과 구분한다.

구조체 정의(struct + 변수/멤버/필드) 
struct Employee
{
    short id;
    int age;
    double wage;
};
함수 원형 정의/선언 -> 컴파일러가 함수의 리턴값, 정확한 개수/데이터형의 전달인자를 사용하는지 검사하는걸 보장
=> 헤더파일(1. 함수 원형 2. #define이나 const를 사용하는 기호상수
3. 구조체 선언 4. 클래스 선언 5. 템플릿 선언 6. 인라인 함수)

구조체와 함수를 사용하는 main함수 사용

함수 몸체 정의

555555555555555555555555555555555555555555555555555555555555

========================================
7-2. 추상화와 클래스
========================================

========================================
7-3. 클래스 생성자와 파괴자
========================================
틸테(~) : 파괴자

========================================
7-4. this 포인터, 클래스 객체 배열
======================================== 


========================================
8-1. 연산자 오버로딩
========================================



========================================
8-2. 프렌드
========================================
 
========================================
8-3. << 연산자 오버로딩
========================================



========================================
9-1. 상속 기본
========================================

객체 지향 프로그램의 목적
재사용가능한 코드를 제공하는 것 -> 함수로써 구현 -> 함수의 이름으로 호출해 사용
                                            -> 클래스로써 구현 -> 클래스를 확장,수정하기 위한 상속

클래스로 객체를 만든다.
Q. 파생클래스가 기초클래스의 private에 접근하는 법
A. 프로그램이 파생클래스의 객체를 생성할때 기초클래스에 먼저 객체 생성 -> 
기초클래스의 객체에다가 덧붙이는 방식으로 파생클래스의 객체를 생성

프로그램이 파생클래스의 생성자에 몸체안에 들어가기 이전에
기초클래스의 객체가 먼저 생성되어야한다.

멤버 초기자 리스트 문법을 사용
NewTime::NewTime() : Time(){} // Time객체 생성 후 매개변수의 자격으로 NewTime 객체에 전달하게 된다.


상속
1. 기존 클래스에 새로운 기능 추가 가능
2. 클래스가 나타내고 있는 데이터에 다른 것을 더 추가할 수 있다.
3. 클래스 메서드가 동작하는 방식을 변경할 수 있다.

파생클래스 제작
class 파생클래스명 : public 원래클래스명(=기초/원형클래스명){};

파생클래스 특징
기초클래스의 public은 접근 가능, private는 접근 불가



생성자 (Constructor)는 해당 클래스의 객체가 인스턴스화될 때 
자동으로 호출되는 특수한 종류의 멤버 함수다. 
생성자는 일반적으로 클래스의 멤버 변수를 적절한 기본값 또는 
사용자 제공 값으로 초기화하거나 클래스를 사용하는 데 필요한 설정
(ex. 파일 열기 등)이 필요한 경우 사용된다.
#include <cassert>

class Fraction
{
private:
    int m_numerator;
    int m_denominator;

public:
    Fraction() // 기본 생성자
    {
         m_numerator = 0;
         m_denominator = 1;
    }

생성자 이름은 클래스와 이름이 같아야 한다.
생성자는 리턴 타입이 없다. (void도 아니다.)

매개 변수를 갖지 않거나 모두 기본값이 설정된 매개 변수를 가지고 있는 생성자를 기본 생성자(Default constructor)라고 한다. 클래스를 인스턴스화할 때 사용자가 초기값을 제공하지 않으면 기본 생성자가 호출된다.

========================================
9-2. Public 다형 상속
========================================

========================================
9-3. 동적 결합
========================================































































































