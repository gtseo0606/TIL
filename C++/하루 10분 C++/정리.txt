하루 10분 c++


====================
1-1. 변수 선언과 규칙
====================
int a; // 선언('자료형' '변수')
a = 7; // 대입

int b = 3; // 초기화(선언과 동시에 대입)

// 이중블록
{ int b;
	{
	int a;
	b = 3; //사용가능
	}
	a = 5; //사용불가
}
====================
1-2. 정수형 자료형과 실수형 자료형
====================
#include <climits>

정수형 short(2byte)<int(4byte)<long(4byte)<long long(8byte)

unsigned int a; // unsigned는 음수값을 사용하지 못함
unsigned shjort b; // 0~65535(-31768~327677) 

실수형 
float a =3.14;


====================
1-3. 문자형 자료형과 bool형 자료형
====================

char : 작은 문자형. + 작은따옴표
bool  : 0(false) or 1(true)

bool a = 0; // 0
bool b = 1; // 1
bool c = 10; // 1


====================
1-4. const 제한자와 데이터형 변환
====================

상수 선언
#define PIE 3.141592 // c 
-> const float PIE 3.141592; //c++

PIE =10 // 불가

데이터형 변환
typeName(a) = (typeName)a

char ch = 'M';
cout << (int)ch << "  " << int(ch) << endl; // 77 77
cout << static_cast<int>(ch) << end l; // 77


====================
1-5. C++ 산술연산자와 auto
====================
>>(몫)
%(나머지)

데이터형 auto
auto x = 0.0; // float 
float y =0;
auto z = 0; // int

====================
2-1. 배열과 문자열
====================

short month[12]; // 선언 (12개의 short형 데이터 저장가능)

short month[12] = { 1, 2, 3 };
cout << month[1] << endl;

char a[] = "Hello" // 큰따옴표에는 null값이 포함
cout << a << endl;


====================
2-2. 사용자 입력과 string
====================
cin.getline(name1, Size) //whitespace 적용가능
= cin.get(name1, Size) 

string(복합데이터형)
char char1[20];
char char2[20] = 'jauar';
string str1;
string str2 = "panda";
// char1 = char2; // 틀림(통째로 값을 대입할 수 없다.)
str1 = str2; // 통째로 값을 대입할 수 있다.

====================
2-3. 구조체
====================

구조체 : 다른 데이터형이 허용되는 데이터의 집합
배열 :  같은 데이터형의 집합

struct MyStruct
{
	string name;
	string position;
	int heght;
	int weight;
};


MyStruct A = {
 	"Son"
	"Striker",
	183,
	77
};

====================
2-4. 공용체와 열거체
====================
union (공용체): 서로 다른 데이터형을 한번에 한가지만 보관가능

union MyUnion
{
	int intVal;
	long longVal;
	float floatVal;
}

enum(열거체) : 기호 상수를 만드는 것에 대한 또다른 방법

enum spectrum {red, orange, green};

0에서부터 2까지 정수값을 각각 나타내는 기호 상수로 만듦

spectrum a;
열거자 간에 산술연산은 허용x


int b;
b = blue
b = blue+3

====================
2-5. 포인터와 메모리 해제 1
====================
int *a; // c 스타일
-> int* a; // c++ 스타일
int* c,d // c는 포인터 변수, d는 int형 변수

증가연산자, 감소연산자

====================
2-6. 포인터와 메모리 해제 2
====================


====================
2-7. 포인터 연산
====================



====================
3-4. 반복문의 활용
====================

int a[5] = { 1, 3, 5, 7, 9 }

// 중첩루프 : 2차원 배열
int temp[4][5];




====================
if 구문과 if else 구문
====================
if (true)
	cout << "조건이 참입니다.",
if (false)
	cout << "조건이 거짓입니다.";



if (true){
	cout 
	cout <<endl;

else {
}

if (false)
else if (true)
else 




====================
논리 표현식
====================

논리합(|| = or), 논리곱(&& = and), 논리부정 연산자(! = not )


====================
switch 구문과 break continue 구문
====================

switch (a)
{
case 1:
	cout << " 
	break;

case 2:
	cout << " 
	break;

defalut:
	cout
	break;
}



====================
함수의 기초
====================



리턴값이 있는 타입
리턴값이 없는 타입





파라미터 : 함수의 특성을 나타내는 매개변수 
void helloCPP(int, int); //파라미터
int main() {
	helloCPP(times, times2) //전달인자, 아규먼트
	return 0;
}

void helloCPP(int n, int m) { //
}



====================
함수와 배열
====================





====================
함수와 구조체
====================

struct Time //구조체
{
	int hours; // 멤버
	int mins; // 멤버
};

 
Time sum(Time* t1, Time* t2) { // 매개변수가 구조체가 아닌 포인터변수 
	Time total;

	// 구조체.멤버 불가 간접멤버연산자(->)
	// 값에서 멤버로 접근할때 : .
	// 주소에서 멤버로 접근할때 : 간접멤버연산자(->) 
	total.mins = (t1->mins + t2->mins) % minsPerHr;
	total.hours = t1->hours + t2->hours +
			(t1->mins + t2->mins) / minsPerHr;

	return total;



====================
재귀함수와 함수를 지시하는 포인터
====================

재귀
int main() {
void recurs(agumentList){
	if (condumentList

)



함수의 주소 얻는법
int main(){
	cout << func << endl;
	return 0;
}

int func(int n){
	return n+1;
}




====================
인라인 함수와 디폴트 매개변수
====================
인라인 함수 : 프로그램의 실행속도를 높이기 위해 필요
inline float square(float x) {return x*x}

디폴트 매개변수: 매개변수가 없을때 대신 사용
 
int sumArr(int*, int n=1);
 


====================
함수 템플릿
====================

// class 혹은 typeName
template <class Any>




====================
분할 컴파일
====================
555555555555555555555555555555555555555555555555555555555555
집계 데이터 유형 중 하나가 구조체
일반적으로 구조체 이름은 대문자로 시작하여 변수 이름과 구분한다.

구조체 정의(struct + 변수/멤버/필드) 
struct Employee
{
    short id;
    int age;
    double wage;
};
함수 원형 정의/선언 -> 컴파일러가 함수의 리턴값, 정확한 개수/데이터형의 전달인자를 사용하는지 검사하는걸 보장
=> 헤더파일(1. 함수 원형 2. #define이나 const를 사용하는 기호상수
3. 구조체 선언 4. 클래스 선언 5. 템플릿 선언 6. 인라인 함수)

구조체와 함수를 사용하는 main함수 사용

함수 몸체 정의

555555555555555555555555555555555555555555555555555555555555
====================
클래스 생성자와 파괴자
====================
틸테(~) : 파괴자

 


====================
연산자 오버로딩
====================



====================
프렌드
====================
 



====================
상속 기본
====================

객체 지향 프로그램의 목적
재사용가능한 코드를 제공하는 것 -> 함수로써 구현 -> 함수의 이름으로 호출해 사용
                                            -> 클래스로써 구현 -> 클래스를 확장,수정하기 위한 상속

클래스로 객체를 만든다.
Q. 파생클래스가 기초클래스의 private에 접근하는 법
A. 프로그램이 파생클래스의 객체를 생성할때 기초클래스에 먼저 객체 생성 -> 
기초클래스의 객체에다가 덧붙이는 방식으로 파생클래스의 객체를 생성

프로그램이 파생클래스의 생성자에 몸체안에 들어가기 이전에
기초클래스의 객체가 먼저 생성되어야한다.

멤버 초기자 리스트 문법을 사용
NewTime::NewTime() : Time(){} // Time객체 생성 후 매개변수의 자격으로 NewTime 객체에 전달하게 된다.


상속
1. 기존 클래스에 새로운 기능 추가 가능
2. 클래스가 나타내고 있는 데이터에 다른 것을 더 추가할 수 있다.
3. 클래스 메서드가 동작하는 방식을 변경할 수 있다.

파생클래스 제작
class 파생클래스명 : public 원래클래스명(=기초/원형클래스명){};

파생클래스 특징
기초클래스의 public은 접근 가능, private는 접근 불가



생성자 (Constructor)는 해당 클래스의 객체가 인스턴스화될 때 
자동으로 호출되는 특수한 종류의 멤버 함수다. 
생성자는 일반적으로 클래스의 멤버 변수를 적절한 기본값 또는 
사용자 제공 값으로 초기화하거나 클래스를 사용하는 데 필요한 설정
(ex. 파일 열기 등)이 필요한 경우 사용된다.
#include <cassert>

class Fraction
{
private:
    int m_numerator;
    int m_denominator;

public:
    Fraction() // 기본 생성자
    {
         m_numerator = 0;
         m_denominator = 1;
    }

생성자 이름은 클래스와 이름이 같아야 한다.
생성자는 리턴 타입이 없다. (void도 아니다.)

매개 변수를 갖지 않거나 모두 기본값이 설정된 매개 변수를 가지고 있는 생성자를 기본 생성자(Default constructor)라고 한다. 클래스를 인스턴스화할 때 사용자가 초기값을 제공하지 않으면 기본 생성자가 호출된다.



































































































